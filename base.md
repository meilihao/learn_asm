# base

## 汇编语法
### 符号/标签
用来标记程序或数据的位置, 表示它将在汇编或链接过程中被指定内容替换. 引用该符号时就是引用其地址(汇编器在汇编时会用地址取代它).

格式:
```asm
<xxx>:
	...
```

`xxx`是一个符号, 后跟一个`:`和它定义的内容.

### 汇编指令/伪指令
在汇编代码中, 任何以`.`开头的指令都不会被直接编译成机器指令, 这些指令是针对汇编器的指令, 与机器指令集无关, 因此也被成为汇编指令(assembler directives)或为伪指令(pseudo-operations).

具体汇编指令见[这里](assembler_directives.md).

## 寄存器
一些寄存器只有特殊指令可访问, 比如`rip`, `rflags`.

在x86 32bit os上, 寄存器用前缀`e`标识, x86_64 64bit os上用前缀`r`标识.

### 通用寄存器
### 专用寄存器
- rbp : 基址指针寄存器(base pointer), 用于访问函数的参数和局部变量的固定参照物, 是当前栈帧的`常量`.
- rsp : 栈指针(Stack Pointer)寄存器, 存放指向当前栈帧的栈顶的指针
- rip : 保存下一条指令的地址
- rflags

## 寻址
- 立即寻址 : `movq $1, %rax`, 用`$`表示立即寻址, 没有`$`时表示直接寻址
- 直接寻址 : `movq 1, %rax`, 将地址1开始的内容(8B)放入rax.
- 索引寻址 : `movq string_start(, %ecx, 1) %eax`, `地址或偏移(%基址或偏移量寄存器, %索引寄存器, 比例因子)`, addr = `地址或偏移 + %基址或偏移量寄存器 + %索引寄存器*比例因子`
- 间接寻址 : `movq (%rax), %rbx`, 从寄存器指定的地址加载值
- 基址寻址 : `movq 4(%rax), %rbx`, addr =  (%rax) + 4

## 中断
中断会中断正常的流程, 把控制权从应用程序转给kernel的中断处理程序.

## 函数调用约定
在 gcc c语言中约定, 栈是实现函数的局部变量, 参数和返回地址的关键因素.

> C语言的调用约定也被称为ABI, 即应用程序二进制接口.

函数调用过程:
1. 在执行函数前, 会将函数参数按逆序压入栈中, 然后执行call 指令. call指令会做两件事: 1. 将下一条指令的地址即返回地址压入栈中, 然后将rip指向被调函数.

1. 被调函数通过`pushq %rbp`保存当前的基址寄存器. 再用`movq %rsp, %rbp`, 即可用相对于rbp的固定索引来访问函数参数. 对当前栈帧而言rbp是常量. 之后开始执行被调函数的代码.

> 栈帧包含一个函数中使用过的所有栈变量, 包括参数, 局部变量和返回地址.

> 栈变量称为局部变量的原因: 当函数返回后, 栈帧已不存在.

1. 当被调函数执行完毕后, 会做三件事:
	1. 将函数返回值放入rax
	1. 将栈恢复到调用函数时的状态(移除当前栈帧, 将rbp重置为上一个栈帧的rbp)
	1. 将控制权还给调用函数, 这通过ret指令实现: 将栈顶值弹出, 并将rip置为该值

> 调用函数时需要假设, 当前的所有寄存器的内容都会被覆盖(除了rbp, 因为其由被调函数在函数开始时保存), 因此需要注意现场保护.